{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/query-generator-typescript.ts"],
  "sourcesContent": ["import NodeUtil from 'node:util';\nimport isObject from 'lodash/isObject';\nimport { AssociationPath } from '../../expression-builders/association-path.js';\nimport { Attribute } from '../../expression-builders/attribute.js';\nimport { BaseSqlExpression } from '../../expression-builders/base-sql-expression.js';\nimport { Cast } from '../../expression-builders/cast.js';\nimport { Col } from '../../expression-builders/col.js';\nimport { DialectAwareFn } from '../../expression-builders/dialect-aware-fn.js';\nimport { Fn } from '../../expression-builders/fn.js';\nimport { Identifier } from '../../expression-builders/identifier.js';\nimport { JsonPath } from '../../expression-builders/json-path.js';\nimport { List } from '../../expression-builders/list.js';\nimport { Literal } from '../../expression-builders/literal.js';\nimport { Value } from '../../expression-builders/value.js';\nimport { Where } from '../../expression-builders/where.js';\nimport type { Attributes, Model, ModelStatic } from '../../model.js';\nimport { Op } from '../../operators.js';\nimport type { BindOrReplacements, Expression, Sequelize } from '../../sequelize.js';\nimport { bestGuessDataTypeOfVal } from '../../sql-string.js';\nimport { isDictionary, isNullish, isPlainObject, isString } from '../../utils/check.js';\nimport { noOpCol } from '../../utils/deprecations.js';\nimport { quoteIdentifier } from '../../utils/dialect.js';\nimport { isModelStatic } from '../../utils/model-utils.js';\nimport { EMPTY_OBJECT } from '../../utils/object.js';\nimport { injectReplacements } from '../../utils/sql.js';\nimport { attributeTypeToSql, validateDataType } from './data-types-utils.js';\nimport { AbstractDataType } from './data-types.js';\nimport type { BindParamOptions, DataType } from './data-types.js';\nimport type { AbstractQueryGenerator } from './query-generator.js';\nimport type { TableName, TableNameWithSchema } from './query-interface.js';\nimport type { WhereOptions } from './where-sql-builder-types.js';\nimport { PojoWhere, WhereSqlBuilder, wrapAmbiguousWhere } from './where-sql-builder.js';\nimport type { AbstractDialect } from './index.js';\n\nexport type TableNameOrModel = TableName | ModelStatic;\n\n// keep REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS updated when modifying this\nexport interface RemoveIndexQueryOptions {\n  concurrently?: boolean;\n  ifExists?: boolean;\n  cascade?: boolean;\n}\n\nexport const REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof RemoveIndexQueryOptions>(['concurrently', 'ifExists', 'cascade']);\n\nexport interface QueryGeneratorOptions {\n  sequelize: Sequelize;\n  dialect: AbstractDialect;\n}\n\n/**\n * Options accepted by {@link AbstractQueryGeneratorTypeScript#escape}\n */\nexport interface EscapeOptions extends FormatWhereOptions {\n  readonly type?: DataType | undefined;\n}\n\nexport interface FormatWhereOptions extends Bindable {\n  /**\n   * These are used to inline replacements into the query, when one is found inside of a {@link Literal}.\n   */\n  readonly replacements?: BindOrReplacements | undefined;\n\n  /**\n   * The model of the main alias. Used to determine the type & column name of attributes referenced in the where clause.\n   */\n  readonly model?: ModelStatic | undefined;\n\n  /**\n   * The alias of the main table corresponding to {@link FormatWhereOptions.model}.\n   * Used as the prefix for attributes that do not reference an association, e.g.\n   *\n   * ```ts\n   * const where = { name: 'foo' };\n   * ```\n   *\n   * will produce\n   *\n   * ```sql\n   * WHERE \"<mainAlias>\".\"name\" = 'foo'\n   * ```\n   */\n  readonly mainAlias?: string | undefined;\n}\n\n/**\n * Methods that support this option are functions that add values to the query.\n * If {@link Bindable.bindParam} is specified, the value will be added to the query as a bind parameter.\n * If it is not specified, the value will be added to the query as a literal.\n */\nexport interface Bindable {\n  bindParam?: ((value: unknown) => string) | undefined;\n}\n\n// DO NOT MAKE THIS CLASS PUBLIC!\n/**\n * This is a temporary class used to progressively migrate the AbstractQueryGenerator class to TypeScript by slowly moving its functions here.\n * Always use {@link AbstractQueryGenerator} instead.\n */\nexport class AbstractQueryGeneratorTypeScript {\n\n  protected readonly whereSqlBuilder: WhereSqlBuilder;\n  readonly dialect: AbstractDialect;\n  protected readonly sequelize: Sequelize;\n\n  constructor(options: QueryGeneratorOptions) {\n    if (!options.sequelize) {\n      throw new Error('QueryGenerator initialized without options.sequelize');\n    }\n\n    if (!options.dialect) {\n      throw new Error('QueryGenerator initialized without options.dialect');\n    }\n\n    this.sequelize = options.sequelize;\n    this.dialect = options.dialect;\n    // TODO: remove casting once all AbstractQueryGenerator functions are moved here\n    this.whereSqlBuilder = new WhereSqlBuilder(this as unknown as AbstractQueryGenerator);\n  }\n\n  protected get options() {\n    return this.sequelize.options;\n  }\n\n  describeTableQuery(tableName: TableNameOrModel) {\n    return `DESCRIBE ${this.quoteTable(tableName)};`;\n  }\n\n  showIndexesQuery(_tableName: TableNameOrModel): string {\n    throw new Error(`showIndexesQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  removeIndexQuery(\n    _tableName: TableNameOrModel,\n    _indexNameOrAttributes: string | string [],\n    _options?: RemoveIndexQueryOptions,\n  ): string {\n    throw new Error(`removeIndexQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table or the foreign key constraint of a given column.\n   *\n   * @param _tableName The table or associated model.\n   * @param _columnName The name of the column. Not supported by SQLite.\n   * @returns The generated SQL query.\n   */\n  getForeignKeyQuery(_tableName: TableNameOrModel, _columnName?: string): string {\n    throw new Error(`getForeignKeyQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  // TODO: rename to \"normalizeTable\" & move to sequelize class\n  extractTableDetails(\n    tableNameOrModel: TableNameOrModel,\n    options?: { schema?: string, delimiter?: string },\n  ): TableNameWithSchema {\n    const tableNameObject = isModelStatic(tableNameOrModel) ? tableNameOrModel.getTableName()\n      : isString(tableNameOrModel) ? { tableName: tableNameOrModel }\n      : tableNameOrModel;\n\n    if (!isPlainObject(tableNameObject)) {\n      throw new Error(`Invalid input received, got ${NodeUtil.inspect(tableNameOrModel)}, expected a Model Class, a TableNameWithSchema object, or a table name string`);\n    }\n\n    // @ts-expect-error -- TODO: this is added by getTableName on model, and must be removed\n    delete tableNameObject.toString;\n\n    return {\n      ...tableNameObject,\n      schema: options?.schema || tableNameObject.schema || this.options.schema || this.dialect.getDefaultSchema(),\n      delimiter: options?.delimiter || tableNameObject.delimiter || '.',\n    };\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param param table string or object\n   * @param alias alias name\n   */\n  quoteTable(param: TableNameOrModel, alias: boolean | string = false): string {\n    if (isModelStatic(param)) {\n      param = param.getTableName();\n    }\n\n    const tableName = this.extractTableDetails(param);\n\n    if (isObject(param) && ('as' in param || 'name' in param)) {\n      throw new Error('parameters \"as\" and \"name\" are not allowed in the first parameter of quoteTable, pass them as the second parameter.');\n    }\n\n    if (alias === true) {\n      alias = tableName.tableName;\n    }\n\n    let sql = '';\n\n    if (this.dialect.supports.schemas) {\n      // Some users sync the same set of tables in different schemas for various reasons\n      // They then set `searchPath` when running a query to use different schemas.\n      // See https://github.com/sequelize/sequelize/pull/15274#discussion_r1020770364\n      // For this reason, we treat the default schema as equivalent to \"no schema specified\"\n      if (tableName.schema && tableName.schema !== this.dialect.getDefaultSchema()) {\n        sql += `${this.quoteIdentifier(tableName.schema)}.`;\n      }\n\n      sql += this.quoteIdentifier(tableName.tableName);\n    } else {\n      const fakeSchemaPrefix = (tableName.schema && tableName.schema !== this.dialect.getDefaultSchema())\n        ? tableName.schema + (tableName.delimiter || '.')\n        : '';\n\n      sql += this.quoteIdentifier(fakeSchemaPrefix + tableName.tableName);\n    }\n\n    if (alias) {\n      sql += ` AS ${this.quoteIdentifier(alias)}`;\n    }\n\n    return sql;\n  }\n\n  /**\n   * Adds quotes to identifier\n   *\n   * @param identifier\n   * @param _force\n   */\n  // TODO: memoize last result\n  quoteIdentifier(identifier: string, _force?: boolean) {\n    return quoteIdentifier(identifier, this.dialect.TICK_CHAR_LEFT, this.dialect.TICK_CHAR_RIGHT);\n  }\n\n  isSameTable(tableA: TableNameOrModel, tableB: TableNameOrModel) {\n    if (tableA === tableB) {\n      return true;\n    }\n\n    tableA = this.extractTableDetails(tableA);\n    tableB = this.extractTableDetails(tableB);\n\n    return tableA.tableName === tableB.tableName && tableA.schema === tableB.schema;\n  }\n\n  whereQuery<M extends Model>(where: WhereOptions<Attributes<M>>, options?: FormatWhereOptions) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length > 0) {\n      return `WHERE ${query}`;\n    }\n\n    return '';\n  }\n\n  whereItemsQuery<M extends Model>(where: WhereOptions<Attributes<M>> | undefined, options?: FormatWhereOptions) {\n    return this.whereSqlBuilder.formatWhereOptions(where, options);\n  }\n\n  formatSqlExpression(piece: BaseSqlExpression, options?: EscapeOptions): string {\n    if (piece instanceof Literal) {\n      return this.formatLiteral(piece, options);\n    }\n\n    if (piece instanceof Fn) {\n      return this.formatFn(piece, options);\n    }\n\n    if (piece instanceof List) {\n      return this.escapeList(piece.values, options);\n    }\n\n    if (piece instanceof Value) {\n      return this.escape(piece.value, options);\n    }\n\n    if (piece instanceof Identifier) {\n      return this.quoteIdentifier(piece.value);\n    }\n\n    if (piece instanceof Cast) {\n      return this.formatCast(piece, options);\n    }\n\n    if (piece instanceof Col) {\n      return this.formatCol(piece, options);\n    }\n\n    if (piece instanceof Attribute) {\n      return this.formatAttribute(piece, options);\n    }\n\n    if (piece instanceof Where) {\n      if (piece.where instanceof PojoWhere) {\n        return this.whereSqlBuilder.formatPojoWhere(piece.where, options);\n      }\n\n      return this.whereSqlBuilder.formatWhereOptions(piece.where, options);\n    }\n\n    if (piece instanceof JsonPath) {\n      return this.formatJsonPath(piece, options);\n    }\n\n    if (piece instanceof AssociationPath) {\n      return this.formatAssociationPath(piece);\n    }\n\n    if (piece instanceof DialectAwareFn) {\n      return this.formatDialectAwareFn(piece, options);\n    }\n\n    throw new Error(`Unknown sequelize method ${piece.constructor.name}`);\n  }\n\n  protected formatAssociationPath(associationPath: AssociationPath): string {\n    return `${this.quoteIdentifier(associationPath.associationPath.join('->'))}.${this.quoteIdentifier(associationPath.attributeName)}`;\n  }\n\n  protected formatJsonPath(jsonPathVal: JsonPath, options?: EscapeOptions): string {\n    const value = this.escape(jsonPathVal.expression, options);\n\n    if (jsonPathVal.path.length === 0) {\n      return value;\n    }\n\n    return this.jsonPathExtractionQuery(value, jsonPathVal.path, false);\n  }\n\n  /**\n   * The goal of this method is to execute the equivalent of json_unquote for the current dialect.\n   *\n   * @param _arg\n   * @param _options\n   */\n  formatUnquoteJson(_arg: Expression, _options: EscapeOptions | undefined): string {\n    if (!this.dialect.supports.jsonOperations) {\n      throw new Error(`Unquoting JSON is not supported by ${this.dialect.name} dialect.`);\n    }\n\n    throw new Error(`formatUnquoteJson has not been implemented in ${this.dialect.name}.`);\n  }\n\n  /**\n   * @param _sqlExpression \u26A0\uFE0F This is not an identifier, it's a raw SQL expression. It will be inlined in the query.\n   * @param _path The JSON path, where each item is one level of the path\n   * @param _unquote Whether the result should be unquoted (depending on dialect: ->> and #>> operators, json_unquote function). Defaults to `false`.\n   */\n  jsonPathExtractionQuery(_sqlExpression: string, _path: ReadonlyArray<number | string>, _unquote: boolean): string {\n    if (!this.dialect.supports.jsonOperations) {\n      throw new Error(`JSON Paths are not supported in ${this.dialect.name}.`);\n    }\n\n    throw new Error(`jsonPathExtractionQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  protected formatLiteral(piece: Literal, options?: EscapeOptions): string {\n    const sql = piece.val.map(part => {\n      if (part instanceof BaseSqlExpression) {\n        return this.formatSqlExpression(part, options);\n      }\n\n      return part;\n    }).join('');\n\n    if (options?.replacements) {\n      return injectReplacements(sql, this.dialect, options.replacements, {\n        onPositionalReplacement: () => {\n          throw new TypeError(`The following literal includes positional replacements (?).\nOnly named replacements (:name) are allowed in literal() because we cannot guarantee the order in which they will be evaluated:\n\u279C literal(${JSON.stringify(sql)})`);\n        },\n      });\n    }\n\n    return sql;\n  }\n\n  protected formatAttribute(piece: Attribute, options?: EscapeOptions): string {\n    const model = options?.model;\n\n    // This handles special attribute syntaxes like $association.references$, json.paths, and attribute::casting\n    const columnName = model?.modelDefinition.getColumnNameLoose(piece.attributeName)\n      ?? piece.attributeName;\n\n    if (options?.mainAlias) {\n      return `${this.quoteIdentifier(options.mainAlias)}.${this.quoteIdentifier(columnName)}`;\n    }\n\n    return this.quoteIdentifier(columnName);\n  }\n\n  protected formatFn(piece: Fn, options?: EscapeOptions): string {\n    // arguments of a function can be anything, it's not necessarily the type of the attribute,\n    // so we need to remove the type from their escape options\n    const argEscapeOptions = piece.args.length > 0 && options?.type ? { ...options, type: undefined } : options;\n    const args = piece.args.map(arg => {\n      return this.escape(arg, argEscapeOptions);\n    }).join(', ');\n\n    return `${piece.fn}(${args})`;\n  }\n\n  protected formatDialectAwareFn(piece: DialectAwareFn, options?: EscapeOptions): string {\n    // arguments of a function can be anything, it's not necessarily the type of the attribute,\n    // so we need to remove the type from their escape options\n    const argEscapeOptions = piece.args.length > 0 && options?.type ? { ...options, type: undefined } : options;\n\n    return piece.apply(this.dialect, argEscapeOptions);\n  }\n\n  protected formatCast(cast: Cast, options?: EscapeOptions) {\n    const type = this.sequelize.normalizeDataType(cast.type);\n\n    const castSql = wrapAmbiguousWhere(cast.expression, this.escape(cast.expression, { ...options, type }));\n    const targetSql = attributeTypeToSql(type).toUpperCase();\n\n    // TODO: if we're casting to the same SQL DataType, we could skip the SQL cast (but keep the JS cast)\n    //  This is useful because sometimes you want to cast the Sequelize DataType to another Sequelize DataType,\n    //  but they are both the same SQL type, so a SQL cast would be redundant.\n\n    return `CAST(${castSql} AS ${targetSql})`;\n  }\n\n  protected formatCol(piece: Col, options?: EscapeOptions) {\n    // TODO: can this be removed?\n    if (piece.identifiers.length === 1 && piece.identifiers[0].startsWith('*')) {\n      return '*';\n    }\n\n    // Weird legacy behavior\n    const identifiers = piece.identifiers.length === 1 ? piece.identifiers[0] : piece.identifiers;\n\n    // TODO: use quoteIdentifiers?\n    // @ts-expect-error -- quote is declared on child class\n    return this.quote(identifiers, options?.model, undefined, options);\n  }\n\n  /**\n   * Escapes a value (e.g. a string, number or date) as an SQL value (as opposed to an identifier).\n   *\n   * @param value The value to escape\n   * @param options The options to use when escaping the value\n   */\n  escape(value: unknown, options: EscapeOptions = EMPTY_OBJECT): string {\n    if (isDictionary(value) && Op.col in value) {\n      noOpCol();\n      value = new Col(value[Op.col] as string);\n    }\n\n    if (value instanceof BaseSqlExpression) {\n      return this.formatSqlExpression(value, options);\n    }\n\n    if (value === undefined) {\n      throw new TypeError('\"undefined\" cannot be escaped');\n    }\n\n    let { type } = options;\n    if (type != null) {\n      type = this.sequelize.normalizeDataType(type);\n    }\n\n    if (\n      value === null\n      // we handle null values ourselves by default, unless the data type explicitly accepts null\n      && (!(type instanceof AbstractDataType) || !type.acceptsNull())\n    ) {\n      if (options.bindParam) {\n        return options.bindParam(null);\n      }\n\n      return 'NULL';\n    }\n\n    if (type == null || typeof type === 'string') {\n      type = bestGuessDataTypeOfVal(value, this.dialect);\n    } else {\n      type = this.sequelize.normalizeDataType(type);\n    }\n\n    this.validate(value, type);\n\n    if (options.bindParam) {\n      return type.getBindParamSql(value, options as BindParamOptions);\n    }\n\n    return type.escape(value);\n  }\n\n  /**\n   * Validate a value against a field specification\n   *\n   * @param value The value to validate\n   * @param type The DataType to validate against\n   */\n  validate(value: unknown, type: DataType) {\n    if (this.sequelize.options.noTypeValidation || isNullish(value)) {\n      return;\n    }\n\n    if (isString(type)) {\n      return;\n    }\n\n    type = this.sequelize.normalizeDataType(type);\n\n    const error = validateDataType(value, type);\n    if (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Escapes an array of values (e.g. strings, numbers or dates) as an SQL List of values.\n   *\n   * @param values The list of values to escape\n   * @param options\n   *\n   * @example\n   * ```ts\n   * const values = [1, 2, 3];\n   * queryGenerator.escapeList([1, 2, 3]); // '(1, 2, 3)'\n   */\n  escapeList(values: unknown[], options?: EscapeOptions): string {\n    return `(${values.map(value => this.escape(value, options)).join(', ')})`;\n  }\n\n  getToggleForeignKeyChecksQuery(_enable: boolean): string {\n    throw new Error(`${this.dialect.name} does not support toggling foreign key checks`);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAqB;AACrB,sBAAqB;AACrB,8BAAgC;AAChC,uBAA0B;AAC1B,iCAAkC;AAClC,kBAAqB;AACrB,iBAAoB;AACpB,8BAA+B;AAC/B,gBAAmB;AACnB,wBAA2B;AAC3B,uBAAyB;AACzB,kBAAqB;AACrB,qBAAwB;AACxB,mBAAsB;AACtB,mBAAsB;AAEtB,uBAAmB;AAEnB,wBAAuC;AACvC,mBAAiE;AACjE,0BAAwB;AACxB,qBAAgC;AAChC,yBAA8B;AAC9B,oBAA6B;AAC7B,iBAAmC;AACnC,8BAAqD;AACrD,wBAAiC;AAKjC,+BAA+D;AAYxD,MAAM,yCAAyC,oBAAI,IAAmC,CAAC,gBAAgB,YAAY,SAAS,CAAC;AAwD7H,MAAM,iCAAiC;AAAA,EAEzB;AAAA,EACV;AAAA,EACU;AAAA,EAEnB,YAAY,SAAgC;AAC1C,QAAI,CAAC,QAAQ,WAAW;AACtB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAEA,QAAI,CAAC,QAAQ,SAAS;AACpB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AAEvB,SAAK,kBAAkB,IAAI,yCAAgB,IAAyC;AAAA,EACtF;AAAA,EAEA,IAAc,UAAU;AACtB,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA,EAEA,mBAAmB,WAA6B;AAC9C,WAAO,YAAY,KAAK,WAAW,SAAS;AAAA,EAC9C;AAAA,EAEA,iBAAiB,YAAsC;AACrD,UAAM,IAAI,MAAM,gDAAgD,KAAK,QAAQ,OAAO;AAAA,EACtF;AAAA,EAEA,iBACE,YACA,wBACA,UACQ;AACR,UAAM,IAAI,MAAM,gDAAgD,KAAK,QAAQ,OAAO;AAAA,EACtF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,mBAAmB,YAA8B,aAA8B;AAC7E,UAAM,IAAI,MAAM,kDAAkD,KAAK,QAAQ,OAAO;AAAA,EACxF;AAAA;AAAA,EAGA,oBACE,kBACA,SACqB;AACrB,UAAM,sBAAkB,kCAAc,gBAAgB,IAAI,iBAAiB,aAAa,QACpF,uBAAS,gBAAgB,IAAI,EAAE,WAAW,iBAAiB,IAC3D;AAEJ,QAAI,KAAC,4BAAc,eAAe,GAAG;AACnC,YAAM,IAAI,MAAM,+BAA+B,iBAAAA,QAAS,QAAQ,gBAAgB,iFAAiF;AAAA,IACnK;AAGA,WAAO,gBAAgB;AAEvB,WAAO;AAAA,MACL,GAAG;AAAA,MACH,SAAQ,mCAAS,WAAU,gBAAgB,UAAU,KAAK,QAAQ,UAAU,KAAK,QAAQ,iBAAiB;AAAA,MAC1G,YAAW,mCAAS,cAAa,gBAAgB,aAAa;AAAA,IAChE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,OAAyB,QAA0B,OAAe;AAC3E,YAAI,kCAAc,KAAK,GAAG;AACxB,cAAQ,MAAM,aAAa;AAAA,IAC7B;AAEA,UAAM,YAAY,KAAK,oBAAoB,KAAK;AAEhD,YAAI,gBAAAC,SAAS,KAAK,MAAM,QAAQ,SAAS,UAAU,QAAQ;AACzD,YAAM,IAAI,MAAM,qHAAqH;AAAA,IACvI;AAEA,QAAI,UAAU,MAAM;AAClB,cAAQ,UAAU;AAAA,IACpB;AAEA,QAAI,MAAM;AAEV,QAAI,KAAK,QAAQ,SAAS,SAAS;AAKjC,UAAI,UAAU,UAAU,UAAU,WAAW,KAAK,QAAQ,iBAAiB,GAAG;AAC5E,eAAO,GAAG,KAAK,gBAAgB,UAAU,MAAM;AAAA,MACjD;AAEA,aAAO,KAAK,gBAAgB,UAAU,SAAS;AAAA,IACjD,OAAO;AACL,YAAM,mBAAoB,UAAU,UAAU,UAAU,WAAW,KAAK,QAAQ,iBAAiB,IAC7F,UAAU,UAAU,UAAU,aAAa,OAC3C;AAEJ,aAAO,KAAK,gBAAgB,mBAAmB,UAAU,SAAS;AAAA,IACpE;AAEA,QAAI,OAAO;AACT,aAAO,OAAO,KAAK,gBAAgB,KAAK;AAAA,IAC1C;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,gBAAgB,YAAoB,QAAkB;AACpD,eAAO,gCAAgB,YAAY,KAAK,QAAQ,gBAAgB,KAAK,QAAQ,eAAe;AAAA,EAC9F;AAAA,EAEA,YAAY,QAA0B,QAA0B;AAC9D,QAAI,WAAW,QAAQ;AACrB,aAAO;AAAA,IACT;AAEA,aAAS,KAAK,oBAAoB,MAAM;AACxC,aAAS,KAAK,oBAAoB,MAAM;AAExC,WAAO,OAAO,cAAc,OAAO,aAAa,OAAO,WAAW,OAAO;AAAA,EAC3E;AAAA,EAEA,WAA4B,OAAoC,SAA8B;AAC5F,UAAM,QAAQ,KAAK,gBAAgB,OAAO,OAAO;AACjD,QAAI,SAAS,MAAM,SAAS,GAAG;AAC7B,aAAO,SAAS;AAAA,IAClB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,gBAAiC,OAAgD,SAA8B;AAC7G,WAAO,KAAK,gBAAgB,mBAAmB,OAAO,OAAO;AAAA,EAC/D;AAAA,EAEA,oBAAoB,OAA0B,SAAiC;AAC7E,QAAI,iBAAiB,wBAAS;AAC5B,aAAO,KAAK,cAAc,OAAO,OAAO;AAAA,IAC1C;AAEA,QAAI,iBAAiB,cAAI;AACvB,aAAO,KAAK,SAAS,OAAO,OAAO;AAAA,IACrC;AAEA,QAAI,iBAAiB,kBAAM;AACzB,aAAO,KAAK,WAAW,MAAM,QAAQ,OAAO;AAAA,IAC9C;AAEA,QAAI,iBAAiB,oBAAO;AAC1B,aAAO,KAAK,OAAO,MAAM,OAAO,OAAO;AAAA,IACzC;AAEA,QAAI,iBAAiB,8BAAY;AAC/B,aAAO,KAAK,gBAAgB,MAAM,KAAK;AAAA,IACzC;AAEA,QAAI,iBAAiB,kBAAM;AACzB,aAAO,KAAK,WAAW,OAAO,OAAO;AAAA,IACvC;AAEA,QAAI,iBAAiB,gBAAK;AACxB,aAAO,KAAK,UAAU,OAAO,OAAO;AAAA,IACtC;AAEA,QAAI,iBAAiB,4BAAW;AAC9B,aAAO,KAAK,gBAAgB,OAAO,OAAO;AAAA,IAC5C;AAEA,QAAI,iBAAiB,oBAAO;AAC1B,UAAI,MAAM,iBAAiB,oCAAW;AACpC,eAAO,KAAK,gBAAgB,gBAAgB,MAAM,OAAO,OAAO;AAAA,MAClE;AAEA,aAAO,KAAK,gBAAgB,mBAAmB,MAAM,OAAO,OAAO;AAAA,IACrE;AAEA,QAAI,iBAAiB,2BAAU;AAC7B,aAAO,KAAK,eAAe,OAAO,OAAO;AAAA,IAC3C;AAEA,QAAI,iBAAiB,yCAAiB;AACpC,aAAO,KAAK,sBAAsB,KAAK;AAAA,IACzC;AAEA,QAAI,iBAAiB,wCAAgB;AACnC,aAAO,KAAK,qBAAqB,OAAO,OAAO;AAAA,IACjD;AAEA,UAAM,IAAI,MAAM,4BAA4B,MAAM,YAAY,MAAM;AAAA,EACtE;AAAA,EAEU,sBAAsB,iBAA0C;AACxE,WAAO,GAAG,KAAK,gBAAgB,gBAAgB,gBAAgB,KAAK,IAAI,CAAC,KAAK,KAAK,gBAAgB,gBAAgB,aAAa;AAAA,EAClI;AAAA,EAEU,eAAe,aAAuB,SAAiC;AAC/E,UAAM,QAAQ,KAAK,OAAO,YAAY,YAAY,OAAO;AAEzD,QAAI,YAAY,KAAK,WAAW,GAAG;AACjC,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,wBAAwB,OAAO,YAAY,MAAM,KAAK;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,MAAkB,UAA6C;AAC/E,QAAI,CAAC,KAAK,QAAQ,SAAS,gBAAgB;AACzC,YAAM,IAAI,MAAM,sCAAsC,KAAK,QAAQ,eAAe;AAAA,IACpF;AAEA,UAAM,IAAI,MAAM,iDAAiD,KAAK,QAAQ,OAAO;AAAA,EACvF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,wBAAwB,gBAAwB,OAAuC,UAA2B;AAChH,QAAI,CAAC,KAAK,QAAQ,SAAS,gBAAgB;AACzC,YAAM,IAAI,MAAM,mCAAmC,KAAK,QAAQ,OAAO;AAAA,IACzE;AAEA,UAAM,IAAI,MAAM,uDAAuD,KAAK,QAAQ,OAAO;AAAA,EAC7F;AAAA,EAEU,cAAc,OAAgB,SAAiC;AACvE,UAAM,MAAM,MAAM,IAAI,IAAI,UAAQ;AAChC,UAAI,gBAAgB,8CAAmB;AACrC,eAAO,KAAK,oBAAoB,MAAM,OAAO;AAAA,MAC/C;AAEA,aAAO;AAAA,IACT,CAAC,EAAE,KAAK,EAAE;AAEV,QAAI,mCAAS,cAAc;AACzB,iBAAO,+BAAmB,KAAK,KAAK,SAAS,QAAQ,cAAc;AAAA,QACjE,yBAAyB,MAAM;AAC7B,gBAAM,IAAI,UAAU;AAAA;AAAA,iBAElB,KAAK,UAAU,GAAG,IAAI;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEU,gBAAgB,OAAkB,SAAiC;AAC3E,UAAM,QAAQ,mCAAS;AAGvB,UAAM,cAAa,+BAAO,gBAAgB,mBAAmB,MAAM,mBAC9D,MAAM;AAEX,QAAI,mCAAS,WAAW;AACtB,aAAO,GAAG,KAAK,gBAAgB,QAAQ,SAAS,KAAK,KAAK,gBAAgB,UAAU;AAAA,IACtF;AAEA,WAAO,KAAK,gBAAgB,UAAU;AAAA,EACxC;AAAA,EAEU,SAAS,OAAW,SAAiC;AAG7D,UAAM,mBAAmB,MAAM,KAAK,SAAS,MAAK,mCAAS,QAAO,EAAE,GAAG,SAAS,MAAM,OAAU,IAAI;AACpG,UAAM,OAAO,MAAM,KAAK,IAAI,SAAO;AACjC,aAAO,KAAK,OAAO,KAAK,gBAAgB;AAAA,IAC1C,CAAC,EAAE,KAAK,IAAI;AAEZ,WAAO,GAAG,MAAM,MAAM;AAAA,EACxB;AAAA,EAEU,qBAAqB,OAAuB,SAAiC;AAGrF,UAAM,mBAAmB,MAAM,KAAK,SAAS,MAAK,mCAAS,QAAO,EAAE,GAAG,SAAS,MAAM,OAAU,IAAI;AAEpG,WAAO,MAAM,MAAM,KAAK,SAAS,gBAAgB;AAAA,EACnD;AAAA,EAEU,WAAW,MAAY,SAAyB;AACxD,UAAM,OAAO,KAAK,UAAU,kBAAkB,KAAK,IAAI;AAEvD,UAAM,cAAU,6CAAmB,KAAK,YAAY,KAAK,OAAO,KAAK,YAAY,EAAE,GAAG,SAAS,KAAK,CAAC,CAAC;AACtG,UAAM,gBAAY,4CAAmB,IAAI,EAAE,YAAY;AAMvD,WAAO,QAAQ,cAAc;AAAA,EAC/B;AAAA,EAEU,UAAU,OAAY,SAAyB;AAEvD,QAAI,MAAM,YAAY,WAAW,KAAK,MAAM,YAAY,CAAC,EAAE,WAAW,GAAG,GAAG;AAC1E,aAAO;AAAA,IACT;AAGA,UAAM,cAAc,MAAM,YAAY,WAAW,IAAI,MAAM,YAAY,CAAC,IAAI,MAAM;AAIlF,WAAO,KAAK,MAAM,aAAa,mCAAS,OAAO,QAAW,OAAO;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,OAAgB,UAAyB,4BAAsB;AACpE,YAAI,2BAAa,KAAK,KAAK,oBAAG,OAAO,OAAO;AAC1C,uCAAQ;AACR,cAAQ,IAAI,eAAI,MAAM,oBAAG,GAAG,CAAW;AAAA,IACzC;AAEA,QAAI,iBAAiB,8CAAmB;AACtC,aAAO,KAAK,oBAAoB,OAAO,OAAO;AAAA,IAChD;AAEA,QAAI,UAAU,QAAW;AACvB,YAAM,IAAI,UAAU,+BAA+B;AAAA,IACrD;AAEA,QAAI,EAAE,KAAK,IAAI;AACf,QAAI,QAAQ,MAAM;AAChB,aAAO,KAAK,UAAU,kBAAkB,IAAI;AAAA,IAC9C;AAEA,QACE,UAAU,SAEN,EAAE,gBAAgB,uCAAqB,CAAC,KAAK,YAAY,IAC7D;AACA,UAAI,QAAQ,WAAW;AACrB,eAAO,QAAQ,UAAU,IAAI;AAAA,MAC/B;AAEA,aAAO;AAAA,IACT;AAEA,QAAI,QAAQ,QAAQ,OAAO,SAAS,UAAU;AAC5C,iBAAO,0CAAuB,OAAO,KAAK,OAAO;AAAA,IACnD,OAAO;AACL,aAAO,KAAK,UAAU,kBAAkB,IAAI;AAAA,IAC9C;AAEA,SAAK,SAAS,OAAO,IAAI;AAEzB,QAAI,QAAQ,WAAW;AACrB,aAAO,KAAK,gBAAgB,OAAO,OAA2B;AAAA,IAChE;AAEA,WAAO,KAAK,OAAO,KAAK;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,SAAS,OAAgB,MAAgB;AACvC,QAAI,KAAK,UAAU,QAAQ,wBAAoB,wBAAU,KAAK,GAAG;AAC/D;AAAA,IACF;AAEA,YAAI,uBAAS,IAAI,GAAG;AAClB;AAAA,IACF;AAEA,WAAO,KAAK,UAAU,kBAAkB,IAAI;AAE5C,UAAM,YAAQ,0CAAiB,OAAO,IAAI;AAC1C,QAAI,OAAO;AACT,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,WAAW,QAAmB,SAAiC;AAC7D,WAAO,IAAI,OAAO,IAAI,WAAS,KAAK,OAAO,OAAO,OAAO,CAAC,EAAE,KAAK,IAAI;AAAA,EACvE;AAAA,EAEA,+BAA+B,SAA0B;AACvD,UAAM,IAAI,MAAM,GAAG,KAAK,QAAQ,mDAAmD;AAAA,EACrF;AACF;",
  "names": ["NodeUtil", "isObject"]
}
