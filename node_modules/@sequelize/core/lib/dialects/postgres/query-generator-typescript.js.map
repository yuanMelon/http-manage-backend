{
  "version": 3,
  "sources": ["../../../src/dialects/postgres/query-generator-typescript.ts"],
  "sourcesContent": ["import type { Expression } from '../../sequelize.js';\nimport { joinSQLFragments } from '../../utils/join-sql-fragments';\nimport { generateIndexName } from '../../utils/string';\nimport { AbstractQueryGenerator } from '../abstract/query-generator';\nimport type { EscapeOptions, RemoveIndexQueryOptions, TableNameOrModel } from '../abstract/query-generator-typescript';\n\n/**\n * Temporary class to ease the TypeScript migration\n */\nexport class PostgresQueryGeneratorTypeScript extends AbstractQueryGenerator {\n  describeTableQuery(tableName: TableNameOrModel) {\n    const table = this.extractTableDetails(tableName);\n\n    return joinSQLFragments([\n      'SELECT',\n      'pk.constraint_type as \"Constraint\",',\n      'c.column_name as \"Field\",',\n      'c.column_default as \"Default\",',\n      'c.is_nullable as \"Null\",',\n      `(CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\",`,\n      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\",',\n      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\"',\n      'FROM information_schema.columns c',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name,',\n      'cu.column_name, tc.constraint_type',\n      'FROM information_schema.TABLE_CONSTRAINTS tc',\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name',\n      'and tc.constraint_name=cu.constraint_name',\n      `and tc.constraint_type='PRIMARY KEY') pk`,\n      'ON pk.table_schema=c.table_schema',\n      'AND pk.table_name=c.table_name',\n      'AND pk.column_name=c.column_name',\n      `WHERE c.table_name = ${this.escape(table.tableName)}`,\n      `AND c.table_schema = ${this.escape(table.schema!)}`,\n    ]);\n  }\n\n  showIndexesQuery(tableName: TableNameOrModel) {\n    const table = this.extractTableDetails(tableName);\n\n    // TODO [>=6]: refactor the query to use pg_indexes\n    return joinSQLFragments([\n      'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey[:ix.indnkeyatts-1] AS index_fields,',\n      'ix.indkey[ix.indnkeyatts:] AS include_fields, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names,',\n      'pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a , pg_namespace s',\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND',\n      `t.relkind = 'r' and t.relname = ${this.escape(table.tableName)}`,\n      `AND s.oid = t.relnamespace AND s.nspname = ${this.escape(table.schema)}`,\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey, ix.indnkeyatts ORDER BY i.relname;',\n    ]);\n  }\n\n  removeIndexQuery(\n    tableName: TableNameOrModel,\n    indexNameOrAttributes: string | string[],\n    options?: RemoveIndexQueryOptions,\n  ) {\n    if (options?.cascade && options?.concurrently) {\n      throw new Error(`Cannot specify both concurrently and cascade options in removeIndexQuery for ${this.dialect.name} dialect`);\n    }\n\n    let indexName;\n    const table = this.extractTableDetails(tableName);\n    if (Array.isArray(indexNameOrAttributes)) {\n      indexName = generateIndexName(table, { fields: indexNameOrAttributes });\n    } else {\n      indexName = indexNameOrAttributes;\n    }\n\n    return joinSQLFragments([\n      'DROP INDEX',\n      options?.concurrently ? 'CONCURRENTLY' : '',\n      options?.ifExists ? 'IF EXISTS' : '',\n      `${this.quoteIdentifier(table.schema!)}.${this.quoteIdentifier(indexName)}`,\n      options?.cascade ? 'CASCADE' : '',\n    ]);\n  }\n\n  getForeignKeyQuery(tableName: TableNameOrModel, columnName?: string) {\n    const table = this.extractTableDetails(tableName);\n\n    return joinSQLFragments([\n      // conkey and confkey are arrays for composite foreign keys.\n      // This splits them as matching separate rows\n      'WITH unnested_pg_constraint AS (',\n      'SELECT conname, confrelid, connamespace, conrelid, contype, oid,',\n      'unnest(conkey) AS conkey, unnest(confkey) AS confkey',\n      'FROM pg_constraint)',\n      'SELECT \"constraint\".conname as \"constraintName\",',\n      'constraint_schema.nspname as \"constraintSchema\",',\n      'current_database() as \"constraintCatalog\",',\n      '\"table\".relname as \"tableName\",',\n      'table_schema.nspname as \"tableSchema\",',\n      'current_database() as \"tableCatalog\",',\n      '\"column\".attname as \"columnName\",',\n      'referenced_table.relname as \"referencedTableName\",',\n      'referenced_schema.nspname as \"referencedTableSchema\",',\n      'current_database() as \"referencedTableCatalog\",',\n      '\"referenced_column\".attname as \"referencedColumnName\"',\n      'FROM unnested_pg_constraint \"constraint\"',\n      'INNER JOIN pg_catalog.pg_class referenced_table ON',\n      'referenced_table.oid = \"constraint\".confrelid',\n      'INNER JOIN pg_catalog.pg_namespace referenced_schema ON',\n      'referenced_schema.oid = referenced_table.relnamespace',\n      'INNER JOIN pg_catalog.pg_namespace constraint_schema ON',\n      '\"constraint\".connamespace = constraint_schema.oid',\n      'INNER JOIN pg_catalog.pg_class \"table\" ON \"constraint\".conrelid = \"table\".oid',\n      'INNER JOIN pg_catalog.pg_namespace table_schema ON \"table\".relnamespace = table_schema.oid',\n      'INNER JOIN pg_catalog.pg_attribute \"column\" ON',\n      '\"column\".attnum = \"constraint\".conkey AND \"column\".attrelid = \"constraint\".conrelid',\n      'INNER JOIN pg_catalog.pg_attribute \"referenced_column\" ON',\n      '\"referenced_column\".attnum = \"constraint\".confkey AND',\n      '\"referenced_column\".attrelid = \"constraint\".confrelid',\n      `WHERE \"constraint\".contype = 'f'`,\n      `AND \"table\".relname = ${this.escape(table.tableName)}`,\n      `AND table_schema.nspname = ${this.escape(table.schema!)}`,\n      columnName && `AND \"column\".attname = ${this.escape(columnName)};`,\n    ]);\n  }\n\n  jsonPathExtractionQuery(sqlExpression: string, path: ReadonlyArray<number | string>, unquote: boolean): string {\n    const operator = path.length === 1\n      ? (unquote ? '->>' : '->')\n      : (unquote ? '#>>' : '#>');\n\n    const pathSql = path.length === 1\n      // when accessing an array index with ->, the index must be a number\n      // when accessing an object key with ->, the key must be a string\n      ? this.escape(path[0])\n      // when accessing with #>, the path is always an array of strings\n      : this.escape(path.map(value => String(value)));\n\n    return sqlExpression + operator + pathSql;\n  }\n\n  formatUnquoteJson(arg: Expression, options?: EscapeOptions) {\n    return `${this.escape(arg, options)}#>>ARRAY[]::TEXT[]`;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
